# 1장 마이크로서비스 소개

### 독립 소프트웨어 컴포넌트의 문제

- 컴포넌트의 새 인스턴스를 추가할 경우 수동으로 로드 밸런싱을 구성 및 설정해야 한다.
- 플랫폼 내부에서의 동기식 통신은 연쇄 장애를 유발하여 문제가 플랫폼 전체로 퍼진다.
- 인스턴스 들의 구성을 일관성 있게 업데이트 할 수 없다.
- 여러 컴포넌트의 로그 이벤트를 상호 연관시키기 어렵다.

### 마이크로서비스의 정의

- 빠르게 개발하여 지속적인 배포가 가능해야 한다.
- 수동 및 자동으로 쉽게 스케일링 할 수 있어야 한다.
- 아무것도 공유하지 않는 아키텍처를 유지해야 한다. 따라서 서비스간 데이터 저장소는 공유되지 않는다.
- 명확한 인터페이스를 통해서만 통신해야 한다. API 및 메시지 포맷은 버전 관리 전략에 따라 안정적으로 문서화되고 개선되어야 한다.
- 독립적인 런타임 프로세스로 배포되어야 한다.
- 마이크로서비스 인스턴스에는 상태가 없다. 모든 인스턴스는 서비스로 들어오는 요청을 처리할 수 있다.

### 마이크로서비스의 문제

- 동기식 통신을 사용하는 다수의 소형 인스턴스는 **연쇄 장애**를 일으킬 수 있다.
- 다수의 인스턴스를 최신 상태로 유지하는 것이 어렵다.
- 여러 컴포넌트들이 처리에 관여하는 요청은 추적하기 어렵다.
- 다수의 인스턴스를 수동으로 구성 및 관리하는 것은 비용이 많이 들고 오류가 발생하기 쉽다.

### 마이크로서비스 디자인 패턴

- 서비스 검색
    - 클라이언트가 논리 엔드포인트에 요청을 보낼 수 있도록 하고, 요청은 사용가능한 인스턴스 중 하나에 라우팅 된다.
    - 일반적으로 서버 측 라우팅을 사용하여 요청을 받을 엔드포인트를 노출하며, 이 요청은 리버스 프록시를 통해 라우팅된다.
- 에지 서버
    - Public Subnet 에서 외부로 공개되는 유일한 마이크로서비스다. 이외의 마이크로서비스는 내부 네트워크로 숨긴다.
    - 에지 서버는 API 게이트웨이 역할을 포함하면서, 인증, CDN 캐싱, DDos 방어를 위한 보안 등을 포함하는 좀 더 넓은 진입점이라고 할 수 있다.
- 리액티브 마이크로서비스
    - 비동기 프로그래밍 모델을 권장하며, Non-Blocking I/O 를 사용하여 스레드 할당 없는 요청 처리를 지원하는 프레임워크를 사용한다.
- 구성 중앙화
    - 클러스터에 포함된 모든 마이크로서비스 인스턴스의 구성을 한번에 파악할 수 있도록 구성 저장소를 사용하는 별도의 서버를 띄운다.
- 로그 분석 중앙화
    - 각 마이크로서비스 인스턴스를 감지하여 로그 이벤트를 수집하고 검색 가능한 형태로 로그 데이터베이스에 저장
    - 수집한 로그를 검색을 위한 API, 시각화 도구 제공
- 분산 추적
    - 모든 수신 요청 및 이벤트에 Correlation ID (상관 ID) 를 할당하여 중앙 로그 서비스가 이 ID 를 추출해 검색 할 수 있다.
- 서킷 브레이커
    - 블로킹 I/O 를 사용한 동기식 호출을 사용할 경우 문제 지점이 생기면 스레드 풀이 빠르게 소진되어 시스템 전체에 문제가 재귀적으로 전파된다. **문제가 있는 서비스를 감지해 요청을 보내지 않도록 차단하는 방법**이 서킷 브레이커 패턴이다.
    - 실패 횟수, 비율 등을 기준으로 서킷이 열리는 임계치를 설정할 수 있다.
    - 서킷이 열린채로 실패할 경우 대체 경로(Fallback Path) 를 제공할 수 있다. 캐시 데이터 반환, 대체 서비스 호출 등으로 문제를 해결할 수 있다.
- 제어 루프
    - 오케스트레이터는 다수의 서비스를 관찰하고 분석 한 뒤 조치할 수 있는 제어 루프 패턴을 가지고 있다. 매 루프마다 이 패턴이 작동되어 서비스의 상태를 확인하고, 상태를 업데이트 한다.
- 모니터링 및 경고 중앙화
    - 마이크로서비스 인스턴스의 하드웨어 자원 사용량이 너무 높으면 문제의 원인을 찾는 것이 어렵기 때문에, 이 사용량에 대한 모든 메트릭을 분석할 수 있어야 한다.
    - Prometheus, Grafana 를 사용한 모니터링 시스템 패턴을 사용하면 메트릭 조회 API, 시각화 도구를 구축할 수 있다.
